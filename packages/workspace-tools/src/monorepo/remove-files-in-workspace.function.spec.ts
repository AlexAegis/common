import type { Logger } from '@alexaegis/logging';
import { MockLogger } from '@alexaegis/logging/mocks';
import type { Options } from 'globby';
import { join } from 'node:path/posix';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { mockProjectRoot } from '../../__mocks__/fs.js';
import { readFileMock, rmMock } from '../../__mocks__/node:fs/promises.js';
import { DISTRIBUTION_MARK, type PackageJson } from '../index.js';
import { removeFilesInWorkspace } from './remove-files-in-workspace.function.js';

vi.mock('globby', () => {
	return {
		globby: (_patterns: string[], options: Options): string[] => {
			expect(options.absolute).toBeTruthy();
			return [
				join(mockProjectRoot, 'trash'),
				join(mockProjectRoot, 'packages/zed/trash'),
				join(mockProjectRoot, 'packages/zod/trash'),
			];
		},
	};
});

vi.mock('fs');
vi.mock('node:fs/promises');

vi.mock('@alexaegis/fs', async () => {
	const mockReadJson = vi.fn<[string | undefined], Promise<PackageJson | undefined>>((_path) => {
		// For some reason the file cannot be read even though it exists
		return Promise.resolve({
			workspaces: ['packages/*'],
		} as PackageJson);
	});

	const mockReadYaml = vi.fn<[string | undefined], unknown>((_path) => {
		return undefined;
	});

	return {
		readJson: mockReadJson,
		readYaml: mockReadYaml,
		normalizeCwdOption: await vi
			.importActual<typeof import('@alexaegis/fs')>('@alexaegis/fs')
			.then((mod) => mod.normalizeCwdOption),
	};
});

describe('removeFilesInWorkspace', () => {
	let mockLogger: MockLogger;
	let logger: Logger<unknown>;

	beforeEach(() => {
		mockLogger = new MockLogger();
		logger = mockLogger as unknown as Logger<unknown>;
	});

	beforeEach(() => {
		readFileMock.mockImplementation((path) =>
			Promise.resolve(
				path.toString().includes('trash') && !path.toString().includes('zod')
					? DISTRIBUTION_MARK
					: undefined
			)
		);
	});

	afterEach(() => {
		vi.clearAllMocks();
	});

	const filename = './trash';
	const rmOptions = { recursive: true };

	it('should remove files if they exist', async () => {
		await removeFilesInWorkspace(filename, {
			cwd: join(mockProjectRoot, 'packages'),
			logger,
		});

		expect(rmMock).toHaveBeenCalledWith('/foo/bar/trash', rmOptions);
		expect(rmMock).toHaveBeenCalledWith('/foo/bar/packages/zed/trash', rmOptions);
		expect(rmMock).toHaveBeenCalledWith('/foo/bar/packages/zod/trash', rmOptions);

		expect(mockLogger.info).toHaveBeenCalled();
	});

	it('should only remove autogenerated files when ran as safe', async () => {
		await removeFilesInWorkspace(filename, {
			cwd: join(mockProjectRoot, 'packages'),
			safe: true,
			logger,
		});

		expect(rmMock).toHaveBeenCalledWith('/foo/bar/trash', rmOptions);
		expect(rmMock).toHaveBeenCalledWith('/foo/bar/packages/zed/trash', rmOptions);
		expect(rmMock).not.toHaveBeenCalledWith('/foo/bar/packages/zod/trash', rmOptions);

		expect(mockLogger.info).toHaveBeenCalled();
	});

	it('should not remove to any folders when dry', async () => {
		await removeFilesInWorkspace(filename, {
			cwd: join(mockProjectRoot, 'packages'),
			dry: true,
			logger,
		});

		expect(rmMock).not.toHaveBeenCalled();
		expect(mockLogger.info).toHaveBeenCalled();
	});

	it('should log an error if it fails and there is a logger', async () => {
		rmMock.mockRejectedValueOnce('ERROR');

		await removeFilesInWorkspace(filename, {
			cwd: join(mockProjectRoot, 'packages'),
			logger,
		});

		expect(rmMock).toHaveBeenCalled();
		expect(mockLogger.error).toHaveBeenCalled();
	});
});
